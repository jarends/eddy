// Generated by CoffeeScript 1.11.1
(function() {
  var Blinker, Cursor, Line, Meta, Minimap, Renderer, events, getBounds, utils,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  events = require('../events');

  Blinker = require('../service/blinker');

  Cursor = require('../views/cursor');

  Line = require('../views/line');

  Meta = require('../views/meta');

  Minimap = require('../views/minimap');

  utils = require('../../utils/utils');

  getBounds = utils.getBounds;

  Renderer = (function() {
    function Renderer(editor) {
      this.editor = editor;
      this.onSelectionsChanged = bind(this.onSelectionsChanged, this);
      this.onCursorsChanged = bind(this.onCursorsChanged, this);
      this.onTextUpdated = bind(this.onTextUpdated, this);
      this.onBlink = bind(this.onBlink, this);
      this.onFocus = bind(this.onFocus, this);
      this.onScroll = bind(this.onScroll, this);
      this.tick = bind(this.tick, this);
      console.log('Renderer.constructor');
      this.view = this.editor.view;
      this.blinker = this.editor.blinker;
      this.mainCursor = null;
      this.lines = {};
      this.cursors = {};
      this.lineCache = [];
      this.cursorCache = [];
      this.linesDirty = false;
      this.cursorsDirty = false;
      this.selectionsDirty = false;
      this.enabled = false;
      this.bounds = null;
      this.letter = null;
      this.firstLine = -1;
      this.rafTimeout = null;
      this.opts = {
        metaWidth: 60,
        minimapWidth: 120
      };
      this.createView();
      this.enable();
      this.textView.addEventListener('scroll', this.onScroll);
      this.view.addEventListener('focus', this.onFocus, true);
      this.editor.on(events.TEXT_UPDATED, this.onTextUpdated);
      this.editor.on(events.CURSORS_CHANGED, this.onCursorsChanged);
      this.editor.on(events.SELECTIONS_CHANGED, this.onSelectionsChanged);
      this.blinker.on(Blinker.BLINK, this.onBlink);
    }

    Renderer.prototype.createView = function() {
      this.linesDirty = true;
      this.taView = document.createElement('textarea');
      this.metaView = document.createElement('div');
      this.textView = document.createElement('div');
      this.scrollView = document.createElement('div');
      this.preView = document.createElement('pre');
      this.codeView = document.createElement('code');
      this.cursorView = document.createElement('div');
      this.minimap = new Minimap(this.editor);
      this.metaView.className = 'meta-view';
      this.textView.className = 'text-view';
      this.scrollView.className = 'scroll-view';
      this.cursorView.className = 'cursor-view';
      this.view.appendChild(this.taView);
      this.preView.appendChild(this.codeView);
      this.scrollView.appendChild(this.preView);
      this.scrollView.appendChild(this.cursorView);
      this.textView.appendChild(this.scrollView);
      this.view.appendChild(this.metaView);
      this.view.appendChild(this.textView);
      this.view.appendChild(this.minimap.view);
      this.textView.tabIndex = -1;
      this.taView.tabIndex = -1;
      return setTimeout((function(_this) {
        return function() {
          _this.taView.focus();
          return console.log('taView.parent: ', _this.taView.parentNode.parentNode.parentNode);
        };
      })(this));
    };

    Renderer.prototype.enable = function(value) {
      if (value == null) {
        value = true;
      }
      this.enabled = value;
      if (this.enabled) {
        this.rafTimeout = window.requestAnimationFrame(this.tick);
      }
      return this;
    };

    Renderer.prototype.disable = function() {
      this.enabled = false;
      window.cancelAnimationFrame(this.rafTimeout);
      return this;
    };

    Renderer.prototype.getPos = function(event) {
      var x, y;
      if (!this.letter) {
        this.updateFontSize();
      }
      x = event.clientX - 60;
      y = event.clientY + this.textView.scrollTop;
      return {
        x: x,
        y: y,
        w: this.letter.w,
        h: this.letter.h,
        col: Math.floor(x / this.letter.w),
        row: Math.floor(y / this.letter.h)
      };
    };

    Renderer.prototype.updateBounds = function() {
      this.linesDirty = true;
      this.bounds = getBounds(this.textView, this.bounds);
      return this;
    };

    Renderer.prototype.updateFontSize = function() {
      var bounds, span;
      this.linesDirty = true;
      span = document.createElement('span');
      span.textContent = '0';
      this.codeView.appendChild(span);
      bounds = getBounds(span);
      this.letter = {
        w: bounds.width,
        h: bounds.height
      };
      this.codeView.removeChild(span);
      return this;
    };

    Renderer.prototype.drawLines = function() {
      var data, firstLine, i, index, j, line, ref, ref1, ref2, totalCols, totalLines, visibleLines;
      if (!this.bounds) {
        this.updateBounds();
      }
      if (!this.letter) {
        this.updateFontSize();
      }
      this.linesDirty = false;
      totalCols = this.editor.buffer.getMaxCols();
      totalLines = this.editor.buffer.getSize();
      this.scrollView.style.width = (totalCols * this.letter.w) + 'px';
      this.scrollView.style.height = (totalLines * this.letter.h) + 'px';
      visibleLines = Math.round(this.bounds.height / this.letter.h) + 1;
      firstLine = Math.floor(this.textView.scrollTop / this.letter.h);
      ref = this.lines;
      for (i in ref) {
        line = ref[i];
        line.used = false;
      }
      for (i = j = 0, ref1 = visibleLines; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        index = firstLine + i;
        line = this.lines[index];
        data = this.editor.buffer.getLine(index);
        if (index >= totalLines) {
          continue;
        }
        if (!line) {
          line = this.lines[index] = this.lineCache.pop() || new Line(this.editor);
        }
        line.used = true;
        line.update(data);
        if (!line.view.parentElement) {
          line.view.style.top = (this.letter.h * index) + 'px';
          this.codeView.appendChild(line.view);
        }
      }
      ref2 = this.lines;
      for (i in ref2) {
        line = ref2[i];
        if (!line.used) {
          delete this.lines[i];
          this.codeView.removeChild(line.view);
          this.lineCache.push(line);
        }
      }
      return this;
    };

    Renderer.prototype.drawCursors = function() {
      var cursor, data, i, j, numCursors, ref, ref1, ref2;
      if (!this.letter) {
        this.updateFontSize();
      }
      this.cursorsDirty = false;
      ref = this.cursors;
      for (i in ref) {
        cursor = ref[i];
        cursor.used = false;
      }
      numCursors = this.editor.cursors.getSize();
      for (i = j = 0, ref1 = numCursors; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        data = this.editor.cursors.getCursor(i);
        cursor = this.cursors[i];
        if (!cursor) {
          cursor = this.cursors[i] = this.cursorCache.pop() || new Cursor(this);
          this.cursorView.appendChild(cursor.view);
        }
        cursor.update(data);
        if (data.isMain) {
          this.mainCursor = cursor;
          this.scrollTo(cursor);
        }
      }
      ref2 = this.cursors;
      for (i in ref2) {
        cursor = ref2[i];
        if (!cursor.used) {
          delete this.cursors[i];
          this.cursorView.removeChild(cursor.view);
          this.cursorCache.push(cursor);
        }
      }
      return this;
    };

    Renderer.prototype.scrollTo = function(cursor) {
      var sx, sy;
      sx = this.textView.scrollLeft;
      sy = this.textView.scrollTop;
      if (cursor.x < sx) {
        this.textView.scrollLeft = cursor.x;
      } else if (cursor.x > sx + this.bounds.width - 19) {
        this.textView.scrollLeft = cursor.x - this.bounds.width + 19;
      }
      if (cursor.y < sy) {
        this.textView.scrollTop = cursor.y;
      } else if (cursor.y > sy + this.bounds.height - 17 - cursor.height) {
        this.textView.scrollTop = cursor.y - this.bounds.height + 17 + cursor.height;
      }
      return this;
    };

    Renderer.prototype.drawSelections = function() {
      this.selectionsDirty = false;
      return this;
    };

    Renderer.prototype.tick = function() {
      if (this.enabled) {
        this.rafTimeout = window.requestAnimationFrame(this.tick);
      }
      if (this.linesDirty) {
        this.drawLines();
      }
      if (this.cursorsDirty) {
        this.drawCursors();
      }
      if (this.selectionsDirty) {
        this.drawSelections();
      }
      return this;
    };

    Renderer.prototype.onScroll = function() {
      this.linesDirty = true;
      return this;
    };

    Renderer.prototype.onFocus = function() {
      this.taView.focus();
      return this;
    };

    Renderer.prototype.onBlink = function() {
      var cursor, display, i, ref;
      display = this.blinker.visible ? 'block' : 'none';
      ref = this.cursors;
      for (i in ref) {
        cursor = ref[i];
        cursor.view.style.display = display;
      }
      return this;
    };

    Renderer.prototype.onTextUpdated = function() {
      this.linesDirty = true;
      return this;
    };

    Renderer.prototype.onCursorsChanged = function() {
      console.log('Renderer.onCursorsChanged');
      this.cursorsDirty = true;
      return this;
    };

    Renderer.prototype.onSelectionsChanged = function() {
      this.selectionsDirty = true;
      return this;
    };

    return Renderer;

  })();

  module.exports = Renderer;

}).call(this);

//# sourceMappingURL=renderer.js.map
